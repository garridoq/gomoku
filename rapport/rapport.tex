\documentclass{article}
\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage{xcolor}
\usepackage[pdftex]{graphicx}
\usepackage{listings}
\usepackage{amsmath}
\usepackage[a4paper,includeheadfoot,margin=2.54cm]{geometry}
\usepackage{amsfonts}
\usepackage{fancyhdr}
\usepackage{titling}
\usepackage{algorithm}
\usepackage{algpseudocode}
 
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{\theauthor}
\fancyhead[RE,LO]{\thetitle}
\fancyfoot[CE,CO]{\leftmark}
\fancyfoot[LE,RO]{\thepage}

\usepackage[thinlines]{easytable}

\title{Rapport de projet : Gomoku}
\author{Quentin Garrido, Antoine Gélin, Kévin Lor}
\date{22 février 2019}

\begin{document}

\maketitle
\tableofcontents
\pagebreak

\section{Introduction}

Le but de ce projet est de réaliser une "intelligence artificielle" pouvant jouer contre un humain au gomoku.\\
Nous avons choisi d'utiliser un plateau de 8x8 et une victoire avec l'alignement de 5 pions de même couleur.\\
Nous avons programmé en C++ afin d'avoir un langage familier à tout le groupe et qui nous permet d'utiliser
certaines représentations pour nos structures de données que nous verrons par la suite.\\
L'un des membres du groupe s'intéressant au moteurs d'échecs et ayant une connaissance des algorithmes utilisés
nous avons transposé ces méthodes vers le gomoku, qui possède les même caractéristique en étant plus simple.\\

Le projet à été réalisé à travail égal par tous les membres du groupe en suivant la répartition suivante:
\begin{itemize}
	\item Quentin Garrido: Structures de données et parcours des coups
	\item Antoine Gélin: Évaluation des coups et réalisation des tests
	\item Kévin Lor: Évaluation des coups et gestion de la mémoire
\end{itemize}

\section{Utilisation}

Tout le code source est disponible à l'adresse suivante : \textit{https://github.com/garridoq/gomoku}.\\

Tout les éxécutables devraient vous être fournis dans le mail et devraient fonctionner sans devoir
les recompiler. Dans le cas contraire voici la démarche à suivre:\\

Afin de pouvoir compiler les exécutables il faut être sous Linux et avoir g++ d'installé sur la machine.\\
La norme utilisée est le C++14 pour tout le programme.\\

Une fois le code source obtenu il faudra exécuter la commande suivante pour compiler les exécutables:
\begin{lstlisting}[language=bash]
	> make
\end{lstlisting}

Tout en étant dans le dossier du code source.\\

Vous obtiendrez plusieurs exécutables de test, ayant un nom comme \textit{test\_*}.\\
Vous aurez aussi un fichier principal \textit{main} qui vous permettra de jouer contre l'IA.

\pagebreak
%==============================================================================
\section{Structures de données}
\subsection{Représentation du plateau}

Pour représenter le plateau nous n'avons pas utilisé de tableau mais des \textit{bitboards} qui
sont la représentation d'un plateau avec chaque case repréenté par un bit, ainsi si elle est
occupée le bit vaudra 1 et 0 sinon.\\
Le bit de poids fort sera le coin en haut à gauche de notre plateau et celui de poids faible le coin 
en bas à droite. Nous avons alors la représentation suivante pour un plateau de 8x8:

\begin{figure}[!hbt]
	\centering
	\begin{TAB}(e,0.5cm,0.5cm){|c|c|c|c|c|c|c|c|}{|c|c|c|c|c|c|c|c|}
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  & X &  &  \\
		 &  & X & X &  &  &  &  \\
		 &  &  &  & X &  &  &  \\
		 &  &  &  &  & X &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  
	\end{TAB}\hspace{0.5cm}
	\begin{TAB}(e,0.5cm,0.5cm){|c|c|c|c|c|c|c|c|}{|c|c|c|c|c|c|c|c|}
		0 &0  &0  &0  &0  &0  &0  &0  \\
		0 &0  &0  &0  &0  & 1 &0  &0  \\
		0 &0  & 1 & 1 &0  &0  &0  &0  \\
		0 &0  &0  &0  & 1 &0  &0  &0  \\
		0 &0  &0  &0  &0  &1  &0  &0  \\
		0 &0  &0  &0  &0  &0  &0  &0 \\ 
		0 &0  &0  &0  &0  &0  &0  &0 \\
		0 &0  &0  &0  &0  &0  &0  &0 \\ 
	\end{TAB}
	
	\begin{TAB}(e,0.5cm,0.5cm){|c|c|c|c|c|c|c|c|}{|c|c|c|c|c|c|c|c|}
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &O  &  &  &  \\
		 & O &  &  &  &O  &  &  \\
		 &  & O & O &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  
	\end{TAB}\hspace{0.5cm}
	\begin{TAB}(e,0.5cm,0.5cm){|c|c|c|c|c|c|c|c|}{|c|c|c|c|c|c|c|c|}
		0 &0  &0  &0  &0  &0  &0  &0  \\
		0 &0  &0  &0  &0  &0  &0  &0  \\
		0 &0  &0  &0  &1  &0  &0  &0  \\
		0 & 1 &0  &0  &0  &1  &0  &0  \\
		0 &0  &1  &1  &0  &0  &0  &0  \\
		0 &0  &0  &0  &0  &0  &0  &0  \\
		0 &0  &0  &0  &0  &0  &0  &0  \\
		0 &0  &0  &0  &0  &0  &0  &0  
	\end{TAB}
	\caption{Représentation d'un plateau avec les bitboards associés}
\end{figure}

Ainsi nous gagnons en mémoire, une position ne nécessite plus que 128bits pour être stockée
et nous béneficions de l'implémentation en hardware du décalage des nombres, ce qui nous fera
gagner de la rapidité à l'évaluation des coups.\\

C'est ce choix de représentation qui a motivé notre choix d'utiliser le C++ pour le projet.
En effet il est un des rares langages qui nous permet d'accéder à chaque bits individuellement
d'un nombre et de réaliser des opérations logiques bit par bit. \\
Pour représenter un plateau de $n$x$n$ il nous faut $n^2$ bits d'où le choix du plateau 8x8
car un entier au delà de 64bits est plus dur à représenter en C++.\\

Cette réprésentation va aussi simplifier l'évaluation des coups en elle même car il sera
plus simple de réaliser un parcours de motif (pattern) en décalant les bits de ce dernier.

\pagebreak
\subsection{Pattern}

Les patterns seront un élément clef de notre programme car nous permettrons d'évaluer une position.\\
Ils seront eux aussi représentés par des \textit{bitboards} et nous aurons aussi l'information sur leur
\textit{hauteur} et \textit{largeur}.Afin de faciliter le parcours du motif sur le plateau de jeu, nous
ferons commencer les motifs le plus en haut à gauche possible du plateau.

\begin{figure}[!hbt]
	\centering
	\begin{TAB}(e,0.5cm,0.5cm){|c|c|c|c|c|c|c|c|}{|c|c|c|c|c|c|c|c|}
		 &  &  &X  &  &  &  &  \\
		 &  &X  &  &  &  &  &  \\
		 & X &  &  &  &  &  &  \\
		X&  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  
	\end{TAB}\hspace{0.5cm}
	\begin{TAB}(e,0.5cm,0.5cm){|c|c|c|c|c|c|c|c|}{|c|c|c|c|c|c|c|c|}
		0 &0  &0  &1  &0  &0  &0  &0  \\
		0 &0  &1  &0  &0  &0  &0  &0  \\
		0 &1  &0  &0  &0  &0  &0  &0  \\
		1 &0  &0  &0  &0  &0  &0  &0  \\
		0 &0  &0  &0  &0  &0  &0  &0  \\
		0 &0  &0  &0  &0  &0  &0  &0 \\ 
		0 &0  &0  &0  &0  &0  &0  &0 \\
		0 &0  &0  &0  &0  &0  &0  &0 \\ 
	\end{TAB}
	\caption{Représentation d'un motif de taille 4x4 avec son bitboard associé}
\end{figure}

Comme nous pouvons le voir sur cet exemple nous avons un motif de largeur et hauteur 4, placé le plus en haut
à gauche possible qui pourra être représenté par un bitboard assez facilement.\\

Afin de savoir combien de fois un motif est présent dans un bitboard nous utiliserons l'algorithme de parcours
suivant:

\begin{algorithm}
\caption{Algorithme de pattern matching}\label{pattern_matching}
\begin{algorithmic}[1]
\Procedure{Pattern\_matching}{$bitboard, pattern$}
	\State count $\gets$ 0
	\For{$i \gets 0$ \textbf{to} $8-\text{pattern.height}$}
		\For{$j \gets 0$ \textbf{to} $8-\text{pattern.width}$}
			\If{pattern \& bitboard = pattern} \Comment{\& représente un ET logique bit par bit}
				\State count $\gets$ count + 1
			\EndIf
			\State pattern $\gets$ pattern $>>$ 1 \Comment{$>>$ est un décalage de $n$ bits à droite}
		\EndFor
		\State pattern $\gets$ pattern $>>$ pattern.width-1
	\EndFor
	\State \textbf{return} count
\EndProcedure
\end{algorithmic}
\end{algorithm}

Cet algorithme va faire glisser le motif sur le plateau et à chaque fois vérifier si il est présent ou non, en effet
si un motif est présent sur le bitboard en faisant un ET logique bit par bit entre les deux nous devrions retrouver
notre motif.

\pagebreak
\subsection{Coup}

Le coup va être un élément central de notre modélisation car il sera utilisé par toutes les parties du programme.\\
Un coup sera modélisé avec les attributs suivants:
\begin{itemize}
\item plateau : le plateau de jeu avant que le coup soit joué
\item index : l'indice du bit où nous jouons un coup
\item side : joueur qui réalise le coup, BLANC ou NOIR
\item evaluation : l'évaluation de la position après avoir joué le coup\\
\end{itemize}

Nous obtiendrons le plateau après le coup via une procédure qui nous le retournera.\\
Nous avons choisi de ne pas stocker le plateau après le coup en mémoire directement car cette représentation
nous paraissait plus intuitive, et qu'après réflexion nous n'avons pas décelé de différence réelles entre les deux
méthodes, que ce soit en terme de performance ou de mémoire dans notre implémentation finale.\\

Nous pourrions gagner en mémoire avec notre méthode en ne stockant le plateau qu'une seule fois et en donnant cette référence
à tous ses enfants dans l'arbre des coups, ce qui nous ferait économiser de la mémoire mais qui en pratique n'aurait pas fait 
de réelle différence car seule une faible partie de l'arbre est en mémoire à un instant donné.

\subsection{Arbre des coups}

L'arbre des coups nous permettra d'obtenir tous les coups jouables depuis une position jusqu'à une profondeur $n$.\\
Nous représenterons cet arbre par des \textit{noeuds} qui auront les attributs suivants:
\begin{itemize}
\item parent : noeud parent, si nous avons besoin de remonter l'arbre des coups
\item coup : coup associé au noeud
\item enfants : tous les noeuds ayant des coups réalisables depuis le coup du noeud courant \\
\end{itemize}

En pratique nous ne générerons pas tout l'arbre jusqu'à la profondeur d'évaluation pour des raisons de coût en mémoire.\\
En effet un arbre avec 64 coups possibles au départ, une profondeur de recherche de 10 et une taille en mémoire de 256bits
(taille sous estimée par rapport à la réalité) demanderait $ \frac{64!}{(64-10)!}.frac{256}{8} = 1,7\times 10^{19}$ octets de mémoire, 
soit plus de 10 éxaoctets,ce qui est impossible à stocker, que ce soit en mémoire vive ou non.\\
Nous allons donc générer les coups lorsque nous en allons en avoir besoin et tirer avantage de la faible durée de vie d'une variable locale, ainsi
que de l'ordre d'évaluation des coups afin d'avoir seulement un faible nombre de coups chargé en mémoire à un instant donné.

\pagebreak
%==============================================================================
\section{Choix des coups}
\subsection{Negamax}

\begin{algorithm}
\caption{Algorithme du Negamax}\label{negamax}
\begin{algorithmic}[1]
\Procedure{Negamax}{$node, depth$}
	\If{depth = 0}
		\State \textbf{return} \textsc{evaluate}$(node.move)$
	\EndIf
	\State max $\gets -\infty$
	\ForAll{child \textbf{in} node.children}
		\State score $\gets -\textsc{Negamax}(child, depth -1)$
		\If{score $>$ max}
			\State max $\gets$ score
		\EndIf
	\EndFor
	\State \textbf{return} max
\EndProcedure
\end{algorithmic}
\end{algorithm}


\subsection{Élagage alpha-beta}
\pagebreak
%==============================================================================
\section{Évaluation d'une position}

\begin{figure}[!hbt]
	\centering
	\begin{TAB}(e,0.5cm,0.5cm){|c|c|c|c|c|c|c|c|}{|c|c|c|c|c|c|c|c|}
		X &  &  &  &  &  &  &  \\
		 & X &  &  &  &  &  &  \\
		 &  &X  &  &  &  &  &  \\
		 &  &  &X  &  &  &  &  \\
		 &  &  &  &X  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  
	\end{TAB}\hspace{0.5cm}
	\begin{TAB}(e,0.5cm,0.5cm){|c|c|c|c|c|c|c|c|}{|c|c|c|c|c|c|c|c|}
		X &  &  &  &  &  &  &  \\
		X &  &  &  &  &  &  &  \\
		X &  &  &  &  &  &  &  \\
		X &  &  &  &  &  &  &  \\
		X &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  
	\end{TAB}
	
	\begin{TAB}(e,0.5cm,0.5cm){|c|c|c|c|c|c|c|c|}{|c|c|c|c|c|c|c|c|}
		X & X & X & X & X &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  
	\end{TAB}\hspace{0.5cm}
	\begin{TAB}(e,0.5cm,0.5cm){|c|c|c|c|c|c|c|c|}{|c|c|c|c|c|c|c|c|}
		 &  &  &  & X &  &  &  \\
		 &  &  & X &  &  &  &  \\
		 &  & X &  &  &  &  &  \\
		 & X &  &  &  &  &  &  \\
		X &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  \\
		 &  &  &  &  &  &  &  
	\end{TAB}
	\caption{Patterns vérifiés pour la victoire ou non}
\end{figure}


\pagebreak
%==============================================================================
\section{Conlusion}
\subsection{Résultats}

\subsection{Pour aller plus loin}

\pagebreak

\end{document}
